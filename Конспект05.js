/*
Паспорт - самая популярная библиотека node.js для авторизации пользователей.
Стратегия - это способ аутентификации

Правила хранения пароля в БД:
1. Ни в коем случае нельзя хранить пароль в открытую в БД. Их нужно приводить к хешу. Хеш это такой специальный термин
который обозначает процесс преобразования входной строки к УСЛОВНО случайному набору символов. Алгоритмы для 
преобразования доступны в node.js в модуле crypto
Соль это рандомное колличество байт привиденные к строке base64. Эта операции НЕ обратима
Приминение преобразования пароля напрямую в хеш тоже не очень безопасно потому что есть такое понятие как самые
популярные пароли
Существуют наборы радужных таблиц - набор заранее сгенерированных хешей
Для того что бы запутать проникшего злоумышленника мы генерируем соль для каждого пользователя.
Мы устанавливаем БД два поля соль и хеш пароля

Паспорт добавляет в мидвеар 3 метода(login, logout, )
Для того что бы оперировать с пользователями паспорт требует у нас создание двух методов: serializeUser & 
deserializeUser. Они используются для того, что бы мы сказали паспорту как сформировать идентификатор для нашего 
пользователя.
Стратегия passport-local(готовый модуль) это аутентификация через эмейл-пароль.
На основании настроек стратегии, стратегия разберает запрос, и если там есть необходимые параметры вызывает колбек

csrf - общее название для хакерской атаки
Сам принцип атаки очень прост:
Например у нас есть два аккаунта (Вася и Маша). Вася хочет перевести 100р Маше для этого он заходит на наш сайт, 
логинится и введя просту форму (сколько он хочет отправить и кому) в результате формируется следующий запрос -
GET /transferMoney?amount=100&to=Masha. Он делает этот запрос, браузер отправляет все куки нам, мы проверяем что
юзер действительно залогинен, у него хватает денег на балансе все логично и хорошо, но внезапно об этой схеме узнает
злой хакер и он отправляет Васе ссылку - Привет Вася, посмотри на эту картинку! А картинка обернута в ссылку
с параметрами amount=1000&to=Haker. Вася кликает по этой ссылке и отправляет нам запрос. Браузер пошлет нам все куки,
все условия выполнятся и мы переведем все деньги хакеру.

Браузер с запросом автоматически отправляет все куки

защита заключается в том, что в каждой форме требуется одно дополнительное значение и это значение хранится не в 
куках (мы сами задаем это значение(напримр библиотекох csrf)). 

JWT - Json Web Token (по большому счету просто способ кодирования информации)
Проблема в том, что наши сервера перестают заниматься какой-то одной платформой (т.е. они предоставляют информацию не
только для сайтов но и например для IOS приложений (или андроид, или виндовсфон, плейстейшен, иксбок, приставки ТВ)). 
По факту им данные нужны +- одинаковые. Но тут встает вопрос: как же быть с аутентификацией? Система с куки-сессиями
не подходит. Соответственно от сервера требуется немного другое поведение: когда приложение или сайт (клиентское 
приложение) хочет получить доступ к какой-то защищенной информации, то оно как и прежде передает свои какие-то секретные
данные (для простоты логин и пароль) мы проверяем эти данные, но вместо того что бы делать запись в сессию (куку) мы
формируем специальный секретный ключ и его отдаем пользователю и он при каждом запросе нам его отдает. Получается
такая же ситуация как с куками. Таким образом мы не зависим от того, какую платформу мы обслуживаем.

OAuth2 как работает:
Мы находимся на нашем сайте, пользователь видит кнопку залогинится через facebook и нажимает на неё, происходит
редирект(!пользователь уходит полностью с нашего сайта!) и уходит на фейсбук, но уходит не абы куда, а на специальную
страничку в адресе которой наше приложение должно оставить свой application_id(идентификатор нашего приложения в 
системе фейсбук, что бы фейсбук знал от кого пришел запрос) и вторым парамметром специальной странице фейсбука мы
передаем то, какую информацию мы хотим получить(какие поля или права) далее фейсбук проверяет у себя есть ли вообще
такое приложение, можно ли ему запрашить такие данные и если все хорошо то показывает пользователю окно: такое то
приложение хочет получить доступ к вот такой вот информации разрешить? Пользователь говорит да, происходит обратный 
редирект на наш сайт (фейсбук генерирует ссылку редиректа в которой оставляет специальный код) на основании этого
редиректа мы понимаем, что пользователь нам резрешил доступ к его информации, а фейсбук дал нам специальный код.
Дальше происходит часть которая пользователю не видна. 
Мы просим фейсбук дать нам access_token на основании кода который он нам дал и нашего секретного кода приложения,
в ответ мы получаем access_token и refresh_token. Получив acess_token мы только теперь можем получить информацию
которую запрашивали при редиректе.
access_token живет совсем не много времени(например 10 минут) и когда он умирает, что бы не гнать пользователя
заного по всей этой цепочке мы можем использовать refresh_token и при помощи него получаем новый access_token.
А вот когда истекет refresh_token тогда придется проходить всю цепочку заного 

*/
/*
----------------------------Модули для Node.js----------------------------
Модуль это фактически файл который подключается при помощи функции require()

В каждом модуле есть специальная переменная exports. Это ссылка на обьект и то что мы туда положим
вернется как результат функции require()
exports.User = User

Глобальный обьект global аналог обьекта window и переменные которые мы положим в глобал
станут глобальными переменными для всего проекта
global.User = User
На практике обьект глобал практически не используется

Есть три вида модулей: JS, NODE, JSON
JS модуль это примеры с использованием exports (из одного файла в другой)
NODE этот тип модулей носит расширение .node и делается он путем компиляции файла на c++
JSON эти модули используются в тех случаях когда хочется сохранить какие-то данные в простейшем
виде



----------------------------Приемы работы с модулями----------------------------
Обьект модуль является переменной которая существует в каждом модуле
Для её вывода console.log(module)

Переменная module содержит информацию об обьекте данного модуля который по мере того как node.js 
обрабатывает файл постепенно заполняется
Кратко по его свойствам:
1. id - как правило содержит полный путь к файлу (используется внутри ноды, сами мы его использовать
    скорее всего не будем)
2. export - то что выдается наружу
3. parent - ссылка на родительский модуль
4. filename - полное имя файла
5. loaded - (boolean) загрузился ли модуль
6. children - это те модули, которые данный модуль подключил через require
7. paths - По сути все пути по которому будет поиск папки node_modules

пример использования: 
const User = require('./user')
function run() {
    const vasya = new User('Вася')
    const petya = new User('Петя')
}

// если данный модуль кто-то подключил, экспортируем функцию
if (module.parent) {
    exports.run = run
} else {
// иначе запускаем её сами
    run()
}

Когда мы записываем свойство в exports, для того чтобы вынести его из модуля, 
на самом деле мы записываем его в module.exports
exports и this(в контексте модуля) являются ссылками на module.exports

// случай подключения модуля базы данных к разным модулям
Когда node.js впервый раз загружает модуль он полностью задает соответствующий
обьект module с учетом parent, export и аналогичных свойств и запоминает его у себя.
Модуль id, тот самый, который обычно является полным путем к файлу, служит идентификатором
для внутреннего кеша. Node.js как бы запоминает: файл такой-то - для него создан обьект
модуля такой-то, и в следующий раз когда мы получаем тот же файл (а файл по сути дела одинаковый, 
просто пути разные к нему, но абсолютный путь одинаковый) node.js обращается к кешу и берет
все тот же обьект
Т.е. подключаем модуль один раз, кешируем его, и в дальнейшем уже пользуемся обьектом, т.е. заного
файл модуля никогда не читается (но существуют специальные команды которые позволяют убрать 
модуль из кеша, но обычно никто этого не делает)

Если мы хотим чтобы модуль у нас был глобальным (т.е. искался без пути) то он у нас должен быть 
в node_modules либо в NODE_PATH(переменная окружения)

модулю можно передать параметры при подключении, например:
const log = require('logger)(module)



----------------------------Введение в npm (менеджер пакетов ноды)----------------------------
Корень проекта обозначается либо файлом package.json либо папкой node_modules

npm up (update) - проверяет есть ли обновления для установленных модулей

Существуют закрытые npm репозитории для компаний



----------------------------Глобальные модули----------------------------
Установка модуля глобально обозначает установку в системную директорию

Чем глоабльная установка отличается от обычной на примере глобаной установки express:
В первую очередь местом установки
Второе отличие это то, что те бинарники которые есть в свойстве бин файла package.js
будут поставлены по системному пути, это озночает что бинарник express ....
Любые операции с глобальными пакетами осуществляются так же как с простыми но с флагом -g

Глобальный обозначает доступный всем на уровне системы
Основное применение глобальных пакетов сделать доступным бинарник по системному пути



----------------------------Модуль util и наследование----------------------------
util.inspect(obj) - позволяет красиво вывести любой обьект. Поведение этого метода напоминает
поведение метода toString(). Используется когда например нужно вывести представления обьекта в 
текстовый файл (при вызове в консоле обьекта, этот метод вызвается автоматически)

util.format() - получает строку и дальше, следующие параметры, оно в него подставляет



----------------------------Модуль console----------------------------
Консоль является глобальной переменной
console.log - console.info одно и тоже
console.error - console.warn - одно и тоже

console.log - выводит стандартный поток вывода
console.error - выводит поток ошибок

У каждой программы, у каждого процесса есть, как минимум, два потока вывода: первый считается
нормальным выводом, второй считается потоком ошибок

console.trace() выводит текущий стек трейс в поток ошибок



----------------------------События, EventEmitter и утечки памяти----------------------------
Если браузерные обработчики срабатывают в произвольном порядке, то нодовские обработчики срабатывают
четко в том порядке в котором они были назначены
emitter.listeners(event) - возвращает все обработчики на данное событие

Если мы сгенерируем событие error у которого не будет не одного обработчика, то нода выкинет исключение
и сама повалит весь процесс



----------------------------Node.js как веб сервер----------------------------
сервер является евент емитором и при входящем запросе эмиттся событие request

При изменениях в коде ноду нужно перезапускать потому что она уже считала файл, создала обьект module
и теперь пользуется им в кеше. Перезапустив ноду мы перезапишем этот обьект.



----------------------------Эхо сервер на Node.js----------------------------
Если отправить запрос на нод сервер и явно не указать ответ (res) то браузер будет находится
в ожидании ответа (сама нода ничего не отдаст), иначе говорят запрос зависнет

Когда браузер делает запрос, то вместе с url он отправляет дополнительную информацию, что это
за браузер и детали того, что он хочет запросить. Это информация в специально формате и называется
заголовками

connection: keep-alive говорит о том, что браузер хотел бы по этому соединению гнать и гнать запросы

Через метод http.requst нода может обращаться к другим серверам



----------------------------Событийный цикл libUV----------------------------
libUV - это библиотека
Команда listen поподая в node.js проходит через его c++ код, вызывает внутренний метод (в ядре ноды)
который вызывает метод в библиотеке libUV который в свою очередь вешает обработчик(вотчер) соединений 
на данный порт

libUV позволяет делать много операций вводы-вывода одновременно т.е. наш JS может инициировать операцию
и дальше заниматься другими делами таким образом множество операций вводы-вывода могут обрабатываеться
одновременно операционной системой а JS будет просто пересылать данный от одного клиента к другому

Сложные вычисление на JS противопоказаны, что бы не создавалась очередь в libUV
Проблема в том, что пока JS занят, другие задачи, даже которым нужны другие ресурсы (например бд) не
могут продолжить выполнение (для защиты от этого запускают node.js в режиме множества процессов)



----------------------------Потоки в Node.js----------------------------
Есть два основных типа потоков:
stream.Readable - поток чтения, как правило сам он не используется, а используются его наследники:
например fs.ReadStream и Request
stream.Writeble - поток записи, та же история как и с потоком чтения

Поток это ДжаваСкриптовый обьект который получает информацию о ресурсе
Когда создается обьект потока он подключается к источнику данных(например файлу) и пытается начать с 
него читать, когда он что-то прочитал, то он эмитирует событие readble. Это событие означает что данные 
прочитанны и находятся в внутреннем буфере потока который мы можем получить используя вызов read, 
затем мы можем сделать что-то с данными и подождать следующего readble. Когда источник данных иссяк
возникает событие end которое означает, что данных больше не будет

На любом этапе потока можно его закрыть и очистить все источники методом destroy

Потоки экономят память, какой бы большой файл не был, мы единовременно обрабатываем не больше 64кб (можем
менять это значение)



----------------------------Long Polling----------------------------
Long Polling - это когда клиент все время пытается держать рабочие соединение с сервером в котором данные, 
как только будут он их сразу же получит

У GET запросов нет тела. Есть заголовки, url и прочее которые полностью пересылаются и обрабатываются тут же
Если метод POST то он содержит тело (req) которое нужно считать работая как с потоком.



----------------------------Домены----------------------------
Домены предназначены для того, что бы перехватывать любые асинхронные ошибки.

Модуль Домэйн позволяет создавать специальный обьект и если в контексте этого обьекта, вызывать функции то он
перехватит любые ошибки в этих функциях (включая асинхронные)
*/
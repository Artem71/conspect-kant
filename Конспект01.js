/*
Node.js по умоланию ничего не делает с запросом, с этой строны она довольно низкоуровневая.
Мы обязаны сомастоятельно обработать каждый запрос

Server (http) наследник обьекта EventEmitter. Фактически у всех обьектов есть метод on()
Server впервую очередь наследник net.Server у которого свои события

EventEmitter самый обычный обьект, у которого есть внутренний массив хендлеров

{если вызывается событие request значит кто-то его вызвал}

Браузер по умолчанию делает два запроса: помимо странички он запрашивает еще и фавиконку, но не смотря на это
браузер устанавливает только одно соединение в целях экономии ресурсов (установка соединения дорогая операция)
делает это с помощью технологии keep-alive
Так же при помощи keep-alive браузер не только оптимизирует конекшен но и держит его еще некоторое время (3-4-5
минуты в записимости от настроек)

По умолчанию в метод end мы можем отправить только строчку либо бинарные данные

Если путь модуля не относительный, то впервую очередь node будет искать в своем ядре, затем NODE_PATH
затем в node_modules
NODE_PATH - переменная окружения ноды

Дебагинг:
node debug - самый хардкорный
webstorm - хороший дебагер
node-inspector - дебагинг ноды через хром дев тулс
встроенный самый топовый метод node --inspect имя файла
-------------------------------------ОЧЕНЬ ВАЖНО!!!------------------------------------------------------------------
Event Loop - событийный цикл. Это такой подход к исполнению программы который используются в ноде, который позволяет 
нам в одном цикле джаваскриптовой машине ВИЭЙТ и в одном процессе нашего веб сервера, выполнять довольно большое
колличество одновременных асинхронных операций.

Две основные программы (два основных инструмента) использующиеся внутри node.js libUV и V8 обе написанны на c++

V8 - Джаваскриптовая машина, т.е. программа которая умеет выполнять JS
libUV - служит для того, что бы взаимодействовать с платформой, т.е. запускать все асинхронные операции. Например
взаимодействовать с сетью или с жестким диском на уровне операционной системы

Событийный цикл регулирует как связываются между собой V8 & libUV

название функции в node setImmediate & nextTick ОШИБОЧНЫ!!! И Их надо менять местами !!
setImmediate - выполнится на сл. тике, а nextTick на текущем
nextTick ВСЕГДА выполнится ПЕРЕД промисом!!!

-Код выполняется строчкой за строчкой, как написан так его и читает V8
-Встретив асинхронную ф-цию V8 откладывает её и идет дальше (откладывает в две очереди (два массива) это
макротаскс и микротаскс). Распределение по очередям происходит так, что V8 смотрит сможет ли он сам выполнить
эту задачу (связанна она как-то с IO)
-После того как закончился JS в файле (который нужно выполнить прямо сейчас) V8 переходит к микротаскам, они 
выпоняются после всего синхронного кода
-ВНИМАНИЕ! После этого завершится событийный цикл (завершится его итерация) т.е. это означает что закончился
весь джаваскрипт который можно выполнить
-теперь в дело вступает libUV
-----------------------------------------------------------------------------------------------------------------

функция object.unref() говорит ноде, что если выполнять больше в коде нечего, то ждать это обьект не надо и можно
закрывать процесс

стандартный метод close() у сервера не завершает его работу, а говорит ему не принимать новых подключений
*/